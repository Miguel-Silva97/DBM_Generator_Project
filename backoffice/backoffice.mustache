const express = require('express');
var router = express.Router();

var {{title}} = require('../Models/{{title}}.js');
var schema{{title}} = require('../Schemas/Schema-{{title}}.json');


router.get('/{{title}}', (req,res) => {
    {{title}}.all((rows) => {
        res.render('list', {
            title: 'Backoffice {{title}}',
            name: '{{title}}',
            columns: function () {
                let prettyNames = [];
                let requiredProps = schema{{title}}.required;
                
                Object.entries(schema{{title}}.properties).forEach(prop => {
                    prop.forEach(p => {
                        if(p.prettyName !== undefined && requiredProps.includes(prop[0])){
                            prettyNames.push(p.prettyName);
                        }
                    });
                });
                
                return prettyNames;
            },
            rows: rows.map(obj => {
                return {
                    properties: Object.keys(obj).map(key => obj[key]),
                    actions: [{
                        link: './{{title}}/Details/' + obj.id,
                        image:{ src: '../../images/read.png', alt: 'read' },
                        tooltip: 'Details'
                        }, {
                        link: './{{title}}/Edit/' + obj.id,
                        image: { src: '../../images/edit.png', alt: 'edit' },
                        tooltip: 'Edit'
                        }, {
                        link: '#',
                        image: { src: '../../images/delete.png', alt: 'delete'},
                        tooltip: 'Delete',
                        events: [{
                        name: "onclick",
                        function: "remove",
                        args: obj.id
                        }]
                    }]
                }
            })
        })
    })
});

router.get('/{{title}}/Details/:id', (req,res) => {
    {{title}}.get(req.params.id, function (row){
        res.render('details', {
            properties: function () {
                let allProps = Object.getOwnPropertyNames(row);
                let validProps = [];

                allProps.forEach((prop) => {
                    if(schema{{title}}.properties.hasOwnProperty(prop)){
                        validProps.push({
                            name: schema{{title}}.properties[prop]["prettyName"],
                            value: row[prop]
                        });
                    }
                })
                return validProps;
            },
            references: function () {
                var allRefs = [];
                if (schema{{title}}.references) {
                schema{{title}}.references.forEach(function (ref) {
                allRefs.push({
                labelRef: ref.label,
                model: ref.model,
                values: ref.relation === "M-M" ? '/{{title}}/' +
                req.params.id : row[(ref.model + "_id").toLowerCase()]
                     });
                    });
                }
                return allRefs;
                },
                get hasReferences() {
                return this.references().length > 0;
                }

        });
    });
});

router.get('/{{title}}/Insert', (req,res) => {
    
        res.render('insert', {
            labels: function() {
                let allProps = Object.getOwnPropertyNames(new {{title}}());
                let varNames = [];
                allProps.forEach((prop) => {
                    if(schema{{title}}.properties.hasOwnProperty(prop)){
                        varNames.push({
                            name: prop
                        })
                    }
                })
                return varNames;
            },
            title : "{{title}}",
            properties: function () {
                let allProps = Object.getOwnPropertyNames(new {{title}}());
                let validProps = [];
                let types = {
                    integer: "text",
                    number: "number",
                    string: "text",
                    date: "date",
                };

                
                allProps.forEach((prop) => {
                    if(schema{{title}}.properties.hasOwnProperty(prop)){
                        validProps.push({
                            name: schema{{title}}.properties[prop]["prettyName"],
                            correctName: prop,
                            type: types[schema{{title}}.properties[prop].type],
                            required: schema{{title}}.required.includes(prop),
                            constraints: function() {
                                let constra = [];
                                let constraintTypes = {
                                    minimum: "min",
                                    maximum: "max",
                                    minLength: "minLength",
                                    maxLength: "maxLength"
                                };
                                Object.keys(constraintTypes).forEach(c => {
                                    if(schema{{title}}.properties[prop][c] !== undefined) {
                                        constra.push({
                                            name: constraintTypes[c],
                                            constValue: schema{{title}}.properties[prop][c]
                                        })
                                    }
                                })
                                return constra;
                            }
                        });
                    }
                })
                return validProps;
            },
            references: function () {
                var allRefs = [];
                if (schema{{title}}.references) {
                    schema{{title}}.references.forEach(function (ref) {
                        allRefs.push({
                            label: ref.label,
                            model: ref.model,
                            isManyToMany: ref.relation === "M-M"
                        });
                    });
                }
                    return allRefs;
                },
            get hasReferences() {
                return this.references().length > 0;
                }
        });
    
});


router.get('/{{title}}/Edit/:id', (req,res) => {
        {{title}}.get(req.params.id, function (row){
        res.render('edit', {
            
            id: req.params.id,
            labels: function() {
                let allProps = Object.getOwnPropertyNames(new {{title}}());
                let varNames = [];
                allProps.forEach((prop) => {
                    if(schema{{title}}.properties.hasOwnProperty(prop)){
                        varNames.push({
                            name: prop
                        })
                    }
                })
                return varNames;
            },
            title : "{{title}}",
            properties: function () {
                let allProps = Object.getOwnPropertyNames(new {{title}}());
                let validProps = [];
                let types = {
                    integer: "text",
                    number: "number",
                    string: "text",
                    date: "date",
                };
                
                
                allProps.forEach((prop) => {
                    if(schema{{title}}.properties.hasOwnProperty(prop)){
                        validProps.push({
                            name: schema{{title}}.properties[prop]["prettyName"],
                            correctName: prop,
                            type: types[schema{{title}}.properties[prop].type],
                            value: row[prop],
                            required: schema{{title}}.required.includes(prop),
                            constraints: function() {
                                let constra = [];
                                let constraintTypes = {
                                    minimum: "min",
                                    maximum: "max",
                                    minLength: "minLength",
                                    maxLength: "maxLength"
                                };
                                Object.keys(constraintTypes).forEach(c => {
                                    if(schema{{title}}.properties[prop][c] !== undefined) {
                                        constra.push({
                                            name: constraintTypes[c],
                                            constValue: schema{{title}}.properties[prop][c]
                                        })
                                    }
                                })
                                return constra;
                            }
                            
                        });
                    }
                })
                return validProps;
            },
            references: function () {
                var allRefs = [];
                if (schema{{title}}.references) {
                    schema{{title}}.references.forEach(function (ref) {
                        allRefs.push({
                            label: ref.label,
                            model: ref.model,
                            isManyToMany: ref.relation === "M-M"
                        });
                    });
                }
                    return allRefs;
                },
            get hasReferences() {
                return this.references().length > 0;
                }
        });

    });
    
});

module.exports = router;